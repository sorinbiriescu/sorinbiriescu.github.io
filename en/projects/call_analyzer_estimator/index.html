<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Call analyzer - Time series analysis | Sorin BIRIESCU</title>
<meta name=keywords content="Python,Data wrangling,Data analysis,Data visualisation,Pandas,Altair,Time series">
<meta name=description content="Analyzing calls volume and estimating manpower">
<meta name=author content>
<link rel=canonical href=https://sorinbiriescu.github.io/en/projects/call_analyzer_estimator/>
<meta name=google-site-verification content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css integrity="sha256-b2AFbUTT9+tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=alternate hreflang=en href=https://sorinbiriescu.github.io/en/projects/call_analyzer_estimator/>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Call analyzer - Time series analysis">
<meta property="og:description" content="Analyzing calls volume and estimating manpower">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sorinbiriescu.github.io/en/projects/call_analyzer_estimator/"><meta property="og:image" content="https://sorinbiriescu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="projects">
<meta property="og:site_name" content="Sorin BIRIESCU">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://sorinbiriescu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Call analyzer - Time series analysis">
<meta name=twitter:description content="Analyzing calls volume and estimating manpower">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Call analyzer - Time series analysis","item":"https://sorinbiriescu.github.io/en/projects/call_analyzer_estimator/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Call analyzer - Time series analysis","name":"Call analyzer - Time series analysis","description":"Analyzing calls volume and estimating manpower","keywords":["Python","Data wrangling","Data analysis","Data visualisation","Pandas","Altair","Time series"],"articleBody":"Call analyzer and manpower estimator This is based on one of my previous analyses for my clients. The situation is as follows: my client has an IT support department which receives telephone calls for support request. The team providing support is limited due to budget constraints and needs to do also onsite support as well as the aforementioned remote support.\nMy client wants to know how many persons should be available to pickup telephone calls in certain periods (hour interval, days of the week, month) in order to properly assign the technicians to either provide remote support when needed or go onsite. Too many people picking up calls and there‚Äôs not enought work for everybody and onsite support will encounter delays. Not enough people to pickup telephone calls and the service quality will suffer (and possibly bring also penalties stipulated in the contract).\nThe questions that need answering are:\n What are the overall characteristics of the remote support telephone calls? How many technicians are required to pick up X% of calls within the agreed SLA? What are the chances to have X calls in certain time intervals?  Due to confidentiality of data, the data related to the calls is not real, however I tried as much as possible to respect the distribution of calls during the day, week and periods of the year. In all other aspects, such as column data format, the imaginary data that I‚Äôm using for this analysis example is accurate.\nIn the real situation, the telephone calls data came in XML format exported by an Alcatel-Lucent ACD and imported by another Python script in a SQLite database. The database was used for an in-house build telephone console to visualize call activity in near real-time.\nFirst thing first, the data needs to be imported from the SQLite database and loaded into a Pandas dataframe for analysis.\nData import and cleaning import sqlite3 from sqlite3 import Error import pandas as pd import numpy as np def create_connection(path): connection = None try: connection = sqlite3.connect(path) print(\"Connection to SQLite DB successful\") except Error as e: print(f\"The error '{e}' occurred\") return connection def execute_read_query(connection, query): cursor = connection.cursor() result = None try: cursor.execute(query) result = cursor.fetchall() return result except Error as e: print(f\"The error '{e}' occurred\") connection = create_connection(\"./call_journal.db\") Connection to SQLite DB successful  Data filtering sometimes starts with the SQL query. In my case, I‚Äôm only selecting data that I judged to be relevant to my analysis. However, it‚Äôs good to keep in mind that left out columns may contain relevant or crucial information. It‚Äôs best that in some cases the initial DB is reinvestigated to dig out more useful information.\nselect_call_records = ''' SELECT TicketType, ChargedUserID, SubscriberName, CommunicationType, Date, Time, DateTime, CallDuration, CallDurationMV, RingingDuration FROM call_journal''' db_cols = [\"TicketType\", \"ChargedUserID\", \"SubscriberName\", \"CommunicationType\", \"Date\", \"Time\", \"DateTime\", \"CallDuration\", \"CallDurationMV\", \"RingingDuration\"] call_records = execute_read_query(connection, select_call_records) df = pd.DataFrame(call_records, columns = db_cols) df.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  df.info() RangeIndex: 63670 entries, 0 to 63669 Data columns (total 10 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 TicketType 63670 non-null object 1 ChargedUserID 63670 non-null object 2 SubscriberName 63588 non-null object 3 CommunicationType 63670 non-null object 4 Date 63670 non-null object 5 Time 63670 non-null object 6 DateTime 63670 non-null object 7 CallDuration 63670 non-null object 8 CallDurationMV 63670 non-null object 9 RingingDuration 63670 non-null object dtypes: object(10) memory usage: 4.9+ MB  The important thing after data import is to try to understand what data is presented in the columns. Not being aware of what‚Äôs the purpose of the data or how it was generated could give innacurate results. I‚Äôll come with examples below.\nThe documentation of the source of information (in my case the ACD) was the first step in understanding how it generates the data. After going through (way too many) documentation pages, I found the following:\n calls are registered as tickets in the ACD (tickets are single units of information of certain operations, like calls, agent activity etc.) calls are received first by SubscriberName ACD, then transfered to SubscriberName agents (POSTE 1, POSTE 2, MV etc.) for call pickup or sent to voicemail. This is a very important piece of information as the ACD registers once the call when it reaches the system and another ticket when it‚Äôs transfered and answered by the agent. Basically, the total number of calls is actually HALF. Example below     SubscriberName CommunicationType DateTime DialledNumber     ACD Incoming 2019-11-28 10:38:00 0750.123.456   POSTE 1 IncomingTransfer 2019-11-28 10:38:00 0750.123.456    First, the call reaches ACD, then it gets transfered to agent (POSTE 1).\nCall ‚Äì received ‚Äì ACD ‚Äì transfered ‚Äì POSTE 1\nBasically, we need to drop all rows with SubscriberName ACD to get the real numbers.\nThe missed calls are not marked specifically. The call routing logic is that it‚Äôs either answered by someone or it‚Äôs redirected to voicemail.     SubscriberName CommunicationType DateTime DialledNumber     ACD Incoming 2019-11-28 16:27:00 0750.123.456   MV 1 IncomingTransfer 2019-11-28 16:28:00 0750.123.456    The call reaches the ACD, no one can pickup the call, and the call is redirected to voicemail MV1.\nCall ‚Äì received ‚Äì ACD ‚Äì transfered ‚Äì POSTE 1\nAgain, same history as before, for the same call, 2 tickets are made. We‚Äôll drop the lines with SubscriberName = ACD\ndf = df.loc[df[\"SubscriberName\"] != \"ACD\"] Now, we‚Äôll continue looking into the other columns.\ndf[\"TicketType\"].unique() array(['Call'], dtype=object)  Since ‚ÄúTicketType‚Äù doesn‚Äôt hold other values than ‚ÄúCall‚Äù, it has no value to us, so we‚Äôll drop it.\ndf.drop(labels = [\"TicketType\"], axis = 1, inplace = True) df[\"ChargedUserID\"].unique() array(['13', '14', '10', '33', '32', '44', '11', '15', '12', '59', '30', '42', '01', '04', '03', '05', '02', '06', '07', '08', '43'], dtype=object)  df = df.loc[df[\"SubscriberName\"] != 'ACD group mbx 1'] df = df.loc[df[\"SubscriberName\"].notnull()] df[\"SubscriberName\"].unique() array(['POSTE 4', 'POSTE 5', 'POSTE 1', 'MV 2', 'MV 1', 'POSTE 8', 'POSTE 2', 'POSTE 6', 'POSTE 3', 'POSTE 7'], dtype=object)  df[\"CommunicationType\"].unique() array(['IncomingTransfer', 'Outgoing', 'OutgoingTransfer', 'OutgoingTransferTransit', 'IncomingTransferTransit'], dtype=object)  This will be filtered as well, as we‚Äôre only interested in incoming calls. One curious this is the ‚ÄúIncomingTransferTransit‚Äù value. We‚Äôll check it out:\ndf.loc[df[\"CommunicationType\"] == 'IncomingTransferTransit'] .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  Unfortunately, I could not find something relevand in the documentation and, since it‚Äôs only one value, we‚Äôll drop it.\ndf = df.loc[df[\"CommunicationType\"] != 'IncomingTransferTransit'] One last thing to check is for calls on Saturday and Sunday. During an initial run of this report, the data contained calls received on saturday and sunday.\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"], format = \"%Y-%m-%d\") df[\"Day_nb\"] = df[\"Date\"].dt.dayofweek df = df.loc[~df[\"Day_nb\"].isin([5,6])] df.drop(labels = \"Day_nb\", axis = 1, inplace = True) As a last check, we‚Äôll look at the total values in columns, to check whether we need to dig deeper into the data.\ndf.info() Int64Index: 44890 entries, 0 to 63668 Data columns (total 9 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 ChargedUserID 44890 non-null object 1 SubscriberName 44890 non-null object 2 CommunicationType 44890 non-null object 3 Date 44890 non-null datetime64[ns] 4 Time 44890 non-null object 5 DateTime 44890 non-null object 6 CallDuration 44890 non-null object 7 CallDurationMV 44890 non-null object 8 RingingDuration 44890 non-null object dtypes: datetime64[ns](1), object(8) memory usage: 3.4+ MB  All looks OK so far, we‚Äôll proceed to setting the columns data types\nColumn data format Next, we‚Äôll set the proper type of certain columns\ndf[\"ChargedUserID\"] = df[\"ChargedUserID\"].astype(\"category\") df[\"SubscriberName\"] = df[\"SubscriberName\"].astype(\"category\") df[\"CommunicationType\"] = df[\"CommunicationType\"].astype(\"category\") df[\"Time\"] = pd.to_datetime(df[\"Date\"], format = \"%H:%M:%S\") df[\"DateTime\"] = pd.to_datetime(df[\"DateTime\"], format = \"%Y-%m-%d%H:%M:%S\") df[\"CallDuration\"] = pd.to_timedelta(df[\"CallDuration\"]) df[\"CallDurationMV\"] = pd.to_timedelta(df[\"CallDurationMV\"]) df[\"RingingDuration\"] = pd.to_timedelta(df[\"RingingDuration\"]) df.info() Int64Index: 44890 entries, 0 to 63668 Data columns (total 9 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 ChargedUserID 44890 non-null category 1 SubscriberName 44890 non-null category 2 CommunicationType 44890 non-null category 3 Date 44890 non-null datetime64[ns] 4 Time 44890 non-null datetime64[ns] 5 DateTime 44890 non-null datetime64[ns] 6 CallDuration 44890 non-null timedelta64[ns] 7 CallDurationMV 44890 non-null timedelta64[ns] 8 RingingDuration 44890 non-null timedelta64[ns] dtypes: category(3), datetime64[ns](3), timedelta64[ns](3) memory usage: 2.5 MB  Data Analysis We‚Äôll start with some basic data exploration, to see some trends. Since we‚Äôre only interested in incoming calls, we‚Äôll create a mask and filter the data\nimport altair as alt mask_incoming = (df[\"CommunicationType\"] == \"IncomingTransfer\") df = df.loc[mask_incoming] df[\"Answered\"] = 0 df.loc[df[\"SubscriberName\"].str.startswith('POSTE'), \"Answered\"] = 1 df.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  total_per_day = df.groupby(\"Date\")[\"CommunicationType\"].count().reset_index().rename({\"CommunicationType\": \"Total\"}, axis = 1) total_per_day.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  total_per_month = df.groupby(pd.Grouper(key=\"Date\", freq=\"1M\"))[\"CommunicationType\"].count().reset_index().rename({\"CommunicationType\": \"Total\"}, axis = 1) total_per_month.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  total_heatmap = df.groupby(\"Date\")[\"CommunicationType\"].count().reset_index().rename({\"CommunicationType\": \"Total\"}, axis = 1) heatmap_per_day = alt.Chart(total_heatmap).mark_rect().encode( x='date(Date):O', y='yearmonth(Date):O', color= alt.Color('Total:Q', scale=alt.Scale(scheme='goldred')) ).properties( width=600 ) heatmap_per_day heatmap_per_day_of_week = alt.Chart(total_heatmap.rename({\"CommunicationType\": \"Total\"}, axis = 1)).mark_rect().encode( x='day(Date):O', y='yearmonth(Date):O', color= alt.Color('Total:Q', scale=alt.Scale(scheme='goldred')) ).properties( width=600 ) heatmap_per_day_of_week Estimator Given a level of service, what is the minimum required ammount of agents to fulfill the service in question?\nWe‚Äôll check this by constructing time intervals from calls start and end time and we‚Äôll check at a certain frequency how many time intervals overlap. Since only one person can respond to a call, the total number of overlaps is the number of required agents.\nLet‚Äôs look at a simple example:\nIn the interval 8h00 - 8h30, we received 2 calls that were answered and we missed one call. In order to properly estimate the time occupation, we‚Äôll add 5min (the average conversation time) to missed calls. So, for this interval, we needed 3 agents to answer. In the next interval, 8h30 - 9h00, we still have 2 agents on call (Call1 and Call2), we assume that there is another fictive agent on missed Call3 and we receive another call that we missed. In total, for this interval, we would need 4 agents. In total, we can see that we need:\n   Interval Agents needed     8h00 - 8h30 3   8h30 - 9h00 4   9h00 - 9h30 2    The time interval to check for call status will be smaller (5 min) in order to be more precise in our results.\ndf[\"call_start_dt\"] = df[\"DateTime\"] df[\"call_end_dt\"] = np.nan df.loc[df[\"Answered\"] == 1, \"call_end_dt\"] = df[\"DateTime\"] + df[\"CallDuration\"] average_call_time = df.loc[df[\"Answered\"] == 1,\"CallDuration\"].mean() average_call_time = average_call_time.floor(\"s\") average_call_time Timedelta('0 days 00:05:11')  df.loc[df[\"Answered\"] == 0, \"call_end_dt\"] = df[\"DateTime\"] + pd.to_timedelta(average_call_time, unit = \"S\") df.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  def create_interval(df): df[\"Time_interval\"] = pd.Interval(df[\"call_start_dt\"], df[\"call_end_dt\"]) return df df[\"Time_interval\"] = np.nan df = df.apply(create_interval, axis = 1) df.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  Constructing time intervals between date A and date B, each day with opening hour X and closing hour Y is ‚Ä¶ tricky :(\nunique_date_list = df[\"Date\"].unique() date_range_start = [] date_range_end = [] frequency = pd.Timedelta(\"5 minutes\") for unique_date in unique_date_list: day_range_start = pd.date_range(start = unique_date + pd.Timedelta(\"7 hours 30 minutes\"), end = unique_date + pd.Timedelta(\"18 hours 30 minutes\") - frequency, freq = frequency ) day_range_end = pd.date_range(start = unique_date + pd.Timedelta(\"7 hours 30 minutes\") + frequency, end = unique_date + pd.Timedelta(\"18 hours 30 minutes\"), freq = frequency ) date_range_start += day_range_start date_range_end += day_range_end verification_range = pd.IntervalIndex.from_arrays(date_range_start, date_range_end) verification_range IntervalIndex([(2019-12-20 07:30:00, 2019-12-20 07:35:00], (2019-12-20 07:35:00, 2019-12-20 07:40:00], (2019-12-20 07:40:00, 2019-12-20 07:45:00], (2019-12-20 07:45:00, 2019-12-20 07:50:00], (2019-12-20 07:50:00, 2019-12-20 07:55:00] ... (2020-10-01 18:05:00, 2020-10-01 18:10:00], (2020-10-01 18:10:00, 2020-10-01 18:15:00], (2020-10-01 18:15:00, 2020-10-01 18:20:00], (2020-10-01 18:20:00, 2020-10-01 18:25:00], (2020-10-01 18:25:00, 2020-10-01 18:30:00]], closed='right', dtype='interval[datetime64[ns]]')  result = [] for verification_interval in verification_range: counter = 0 # we're filtering the main dataframe as there is no point in searching for overlaps in the next day mask_filter_left = (df[\"call_start_dt\"]  verification_interval.left - pd.Timedelta(\"24h\")) mask_filter_right = (df[\"call_end_dt\"]  verification_interval.right + pd.Timedelta(\"24h\")) call_intervals = df.loc[(mask_filter_left \u0026 mask_filter_right), \"Time_interval\"] for call_interval in call_intervals: if verification_interval.overlaps(call_interval): counter += 1 result.append({\"time_interval\": verification_interval, \"total_overlaps\": counter}) estimator = pd.DataFrame(result) estimator.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  We got our results, but we‚Äôll only keep the starting date of the interval, it‚Äôs much easier to construct graphs with simple dates than time intervals.\nestimator[\"DateTime\"] = estimator[\"time_interval\"].apply(lambda x: x.left) estimator = estimator.loc[:,(\"total_overlaps\",\"DateTime\")].rename({\"total_overlaps\": \"Total\"}, axis = 1) estimator.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  Average / Min / Max nb of agents required per hour per day estimator[\"Hour\"] = estimator[\"DateTime\"].dt.hour estimator[\"Day_nb\"] = estimator[\"DateTime\"].dt.day estimator.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  def calc_agg(df): df[\"Total_mean\"] = df[\"Total\"].mean() df[\"Total_mean\"] = np.ceil(df[\"Total_mean\"]) df[\"Total_min\"] = df[\"Total\"].min() df[\"Total_max\"] = df[\"Total\"].max() return df heatmap_table = estimator.groupby([\"Day_nb\", \"Hour\"]).apply(calc_agg).reset_index(drop = True) heatmap_table.sample(5) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  alt.data_transformers.disable_max_rows() base = alt.Chart(heatmap_table.rename({\"Day_nb\": \"Date\", \"Total_mean\": \"Mean\", \"Total_max\": \"Max\"})).encode( x='Hour:O', y='Day_nb:O' ) color_avg = base.mark_rect().encode( color= alt.Color('Total_mean:Q', scale=alt.Scale(scheme='goldred')) ) text_avg = base.mark_text(baseline='middle').encode( text = 'max(Total_mean):Q' ) heatmap = color_avg + text_avg heatmap color_max = base.mark_rect().encode( color= alt.Color('Total_max:Q', scale=alt.Scale(scheme='goldred')) ) text_max = base.mark_text(baseline='middle').encode( text = 'max(Total_max):Q' ) heatmap = color_max + text_max #heatmap ","wordCount":"2172","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sorinbiriescu.github.io/en/projects/call_analyzer_estimator/"},"publisher":{"@type":"Organization","name":"Sorin BIRIESCU","logo":{"@type":"ImageObject","url":"https://sorinbiriescu.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://sorinbiriescu.github.io/en/ accesskey=h title="Sorin BIRIESCU (Alt + H)">Sorin BIRIESCU</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://sorinbiriescu.github.io/fr/ title="üá´üá∑ En Fran√ßais" aria-label=":fr: En Fran√ßais">üá´üá∑ En Fran√ßais</a>
</li>
</ul>
</span>
</div>
<ul id=menu>
<li>
<a href=https://sorinbiriescu.github.io/en/bio title="Bio / CV">
<span>Bio / CV</span>
</a>
</li>
<li>
<a href=https://sorinbiriescu.github.io/en/projects/ title=Projects>
<span>Projects</span>
</a>
</li>
<li>
<a href=https://sorinbiriescu.github.io/en/skills title=Skills>
<span>Skills</span>
</a>
</li>
<li>
<a href=https://sorinbiriescu.github.io/en/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://sorinbiriescu.github.io/en/contact title=Contact>
<span>Contact</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Call analyzer - Time series analysis
</h1>
<div class=post-description>
Analyzing calls volume and estimating manpower
</div>
<div class=post-meta>11 min
</div>
</header>
<div class=post-content><h1 id=call-analyzer-and-manpower-estimator>Call analyzer and manpower estimator<a hidden class=anchor aria-hidden=true href=#call-analyzer-and-manpower-estimator>#</a></h1>
<p>This is based on one of my previous analyses for my clients. The situation is as follows: my client has an IT support department which receives telephone calls for support request. The team providing support is limited due to budget constraints and needs to do also onsite support as well as the aforementioned remote support.</p>
<p>My client wants to know how many persons should be available to pickup telephone calls in certain periods (hour interval, days of the week, month) in order to properly assign the technicians to either provide remote support when needed or go onsite. Too many people picking up calls and there&rsquo;s not enought work for everybody and onsite support will encounter delays. Not enough people to pickup telephone calls and the service quality will suffer (and possibly bring also penalties stipulated in the contract).</p>
<p>The questions that need answering are:</p>
<ol>
<li>What are the overall characteristics of the remote support telephone calls?</li>
<li>How many technicians are required to pick up X% of calls within the agreed SLA?</li>
<li>What are the chances to have X calls in certain time intervals?</li>
</ol>
<p>Due to confidentiality of data, the data related to the calls is not real, however I tried as much as possible to respect the distribution of calls during the day, week and periods of the year. In all other aspects, such as column data format, the imaginary data that I&rsquo;m using for this analysis example is accurate.</p>
<p>In the real situation, the telephone calls data came in XML format exported by an Alcatel-Lucent ACD and imported by another Python script in a SQLite database. The database was used for an in-house build telephone console to visualize call activity in near real-time.</p>
<p>First thing first, the data needs to be imported from the SQLite database and loaded into a Pandas dataframe for analysis.</p>
<h1 id=data-import-and-cleaning>Data import and cleaning<a hidden class=anchor aria-hidden=true href=#data-import-and-cleaning>#</a></h1>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> sqlite3
<span style=color:#f92672>from</span> sqlite3 <span style=color:#f92672>import</span> Error
<span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
<span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_connection</span>(path):
    connection <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
    <span style=color:#66d9ef>try</span>:
        connection <span style=color:#f92672>=</span> sqlite3<span style=color:#f92672>.</span>connect(path)
        print(<span style=color:#e6db74>&#34;Connection to SQLite DB successful&#34;</span>)

    <span style=color:#66d9ef>except</span> Error <span style=color:#66d9ef>as</span> e:
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;The error &#39;</span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; occurred&#34;</span>)
        
    <span style=color:#66d9ef>return</span> connection
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>execute_read_query</span>(connection, query):
    cursor <span style=color:#f92672>=</span> connection<span style=color:#f92672>.</span>cursor()
    result <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
    <span style=color:#66d9ef>try</span>:
        cursor<span style=color:#f92672>.</span>execute(query)
        result <span style=color:#f92672>=</span> cursor<span style=color:#f92672>.</span>fetchall()
        <span style=color:#66d9ef>return</span> result
    <span style=color:#66d9ef>except</span> Error <span style=color:#66d9ef>as</span> e:
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;The error &#39;</span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39; occurred&#34;</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>connection <span style=color:#f92672>=</span> create_connection(<span style=color:#e6db74>&#34;./call_journal.db&#34;</span>)
</code></pre></div><pre><code>Connection to SQLite DB successful
</code></pre>
<p>Data filtering sometimes starts with the SQL query. In my case, I&rsquo;m only selecting data that I judged to be relevant to my analysis. However, it&rsquo;s good to keep in mind that left out columns may contain relevant or crucial information. It&rsquo;s best that in some cases the initial DB is reinvestigated to dig out more useful information.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>select_call_records <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>    SELECT TicketType,
</span><span style=color:#e6db74>        ChargedUserID,
</span><span style=color:#e6db74>        SubscriberName,
</span><span style=color:#e6db74>        CommunicationType,
</span><span style=color:#e6db74>        Date,
</span><span style=color:#e6db74>        Time,
</span><span style=color:#e6db74>        DateTime,
</span><span style=color:#e6db74>        CallDuration,
</span><span style=color:#e6db74>        CallDurationMV,
</span><span style=color:#e6db74>        RingingDuration
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>    FROM call_journal&#39;&#39;&#39;</span>

db_cols <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;TicketType&#34;</span>,
        <span style=color:#e6db74>&#34;ChargedUserID&#34;</span>,
        <span style=color:#e6db74>&#34;SubscriberName&#34;</span>,
        <span style=color:#e6db74>&#34;CommunicationType&#34;</span>,
        <span style=color:#e6db74>&#34;Date&#34;</span>,
        <span style=color:#e6db74>&#34;Time&#34;</span>,
        <span style=color:#e6db74>&#34;DateTime&#34;</span>,
        <span style=color:#e6db74>&#34;CallDuration&#34;</span>,
        <span style=color:#e6db74>&#34;CallDurationMV&#34;</span>,
        <span style=color:#e6db74>&#34;RingingDuration&#34;</span>]

call_records <span style=color:#f92672>=</span> execute_read_query(connection, select_call_records)

df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(call_records, columns <span style=color:#f92672>=</span> db_cols)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>info()
</code></pre></div><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 63670 entries, 0 to 63669
Data columns (total 10 columns):
 #   Column             Non-Null Count  Dtype 
---  ------             --------------  ----- 
 0   TicketType         63670 non-null  object
 1   ChargedUserID      63670 non-null  object
 2   SubscriberName     63588 non-null  object
 3   CommunicationType  63670 non-null  object
 4   Date               63670 non-null  object
 5   Time               63670 non-null  object
 6   DateTime           63670 non-null  object
 7   CallDuration       63670 non-null  object
 8   CallDurationMV     63670 non-null  object
 9   RingingDuration    63670 non-null  object
dtypes: object(10)
memory usage: 4.9+ MB
</code></pre>
<p>The important thing after data import is to try to understand what data is presented in the columns. Not being aware of what&rsquo;s the purpose of the data or how it was generated could give innacurate results. I&rsquo;ll come with examples below.</p>
<p>The documentation of the source of information (in my case the ACD) was the first step in understanding how it generates the data. After going through (way too many) documentation pages, I found the following:</p>
<ol>
<li>calls are registered as tickets in the ACD (tickets are single units of information of certain operations, like calls, agent activity etc.)</li>
<li>calls are received first by SubscriberName ACD, then transfered to SubscriberName agents (POSTE 1, POSTE 2, MV etc.) for call pickup or sent to voicemail. This is a very important piece of information as the ACD registers once the call when it reaches the system and another ticket when it&rsquo;s transfered and answered by the agent. Basically, the total number of calls is actually HALF. Example below</li>
</ol>
<table>
<thead>
<tr>
<th>SubscriberName</th>
<th>CommunicationType</th>
<th>DateTime</th>
<th>DialledNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACD</td>
<td>Incoming</td>
<td>2019-11-28 10:38:00</td>
<td>0750.123.456</td>
</tr>
<tr>
<td>POSTE 1</td>
<td>IncomingTransfer</td>
<td>2019-11-28 10:38:00</td>
<td>0750.123.456</td>
</tr>
</tbody>
</table>
<p>First, the call reaches ACD, then it gets transfered to agent (POSTE 1).</p>
<p>Call &ndash; received &ndash;> ACD &ndash; transfered &ndash;> POSTE 1</p>
<p>Basically, we need to drop all rows with SubscriberName ACD to get the real numbers.</p>
<ol start=3>
<li>The missed calls are not marked specifically. The call routing logic is that it&rsquo;s either answered by someone or it&rsquo;s redirected to voicemail.</li>
</ol>
<table>
<thead>
<tr>
<th>SubscriberName</th>
<th>CommunicationType</th>
<th>DateTime</th>
<th>DialledNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACD</td>
<td>Incoming</td>
<td>2019-11-28 16:27:00</td>
<td>0750.123.456</td>
</tr>
<tr>
<td>MV 1</td>
<td>IncomingTransfer</td>
<td>2019-11-28 16:28:00</td>
<td>0750.123.456</td>
</tr>
</tbody>
</table>
<p>The call reaches the ACD, no one can pickup the call, and the call is redirected to voicemail MV1.</p>
<p>Call &ndash; received &ndash;> ACD &ndash; transfered &ndash;> POSTE 1</p>
<p>Again, same history as before, for the same call, 2 tickets are made. We&rsquo;ll drop the lines with SubscriberName = ACD</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;ACD&#34;</span>]
</code></pre></div><p>Now, we&rsquo;ll continue looking into the other columns.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;TicketType&#34;</span>]<span style=color:#f92672>.</span>unique()
</code></pre></div><pre><code>array(['Call'], dtype=object)
</code></pre>
<p>Since &ldquo;TicketType&rdquo; doesn&rsquo;t hold other values than &ldquo;Call&rdquo;, it has no value to us, so we&rsquo;ll drop it.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>drop(labels <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;TicketType&#34;</span>], axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, inplace <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;ChargedUserID&#34;</span>]<span style=color:#f92672>.</span>unique()
</code></pre></div><pre><code>array(['13', '14', '10', '33', '32', '44', '11', '15', '12', '59', '30',
       '42', '01', '04', '03', '05', '02', '06', '07', '08', '43'],
      dtype=object)
</code></pre>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;ACD group mbx 1&#39;</span>]
df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>]<span style=color:#f92672>.</span>notnull()]
df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>]<span style=color:#f92672>.</span>unique()
</code></pre></div><pre><code>array(['POSTE 4', 'POSTE 5', 'POSTE 1', 'MV 2', 'MV 1', 'POSTE 8',
       'POSTE 2', 'POSTE 6', 'POSTE 3', 'POSTE 7'], dtype=object)
</code></pre>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>]<span style=color:#f92672>.</span>unique()
</code></pre></div><pre><code>array(['IncomingTransfer', 'Outgoing', 'OutgoingTransfer',
       'OutgoingTransferTransit', 'IncomingTransferTransit'], dtype=object)
</code></pre>
<p>This will be filtered as well, as we&rsquo;re only interested in incoming calls. One curious this is the &ldquo;IncomingTransferTransit&rdquo; value. We&rsquo;ll check it out:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;IncomingTransferTransit&#39;</span>]
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<p>Unfortunately, I could not find something relevand in the documentation and, since it&rsquo;s only one value, we&rsquo;ll drop it.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;IncomingTransferTransit&#39;</span>]
</code></pre></div><p>One last thing to check is for calls on Saturday and Sunday. During an initial run of this report, the data contained calls received on saturday and sunday.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;Date&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_datetime(df[<span style=color:#e6db74>&#34;Date&#34;</span>], format <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;%Y-%m-</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#34;</span>)
df[<span style=color:#e6db74>&#34;Day_nb&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;Date&#34;</span>]<span style=color:#f92672>.</span>dt<span style=color:#f92672>.</span>dayofweek
df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#f92672>~</span>df[<span style=color:#e6db74>&#34;Day_nb&#34;</span>]<span style=color:#f92672>.</span>isin([<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>])]
df<span style=color:#f92672>.</span>drop(labels <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Day_nb&#34;</span>, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, inplace <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
</code></pre></div><p>As a last check, we&rsquo;ll look at the total values in columns, to check whether we need to dig deeper into the data.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>info()
</code></pre></div><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 44890 entries, 0 to 63668
Data columns (total 9 columns):
 #   Column             Non-Null Count  Dtype         
---  ------             --------------  -----         
 0   ChargedUserID      44890 non-null  object        
 1   SubscriberName     44890 non-null  object        
 2   CommunicationType  44890 non-null  object        
 3   Date               44890 non-null  datetime64[ns]
 4   Time               44890 non-null  object        
 5   DateTime           44890 non-null  object        
 6   CallDuration       44890 non-null  object        
 7   CallDurationMV     44890 non-null  object        
 8   RingingDuration    44890 non-null  object        
dtypes: datetime64[ns](1), object(8)
memory usage: 3.4+ MB
</code></pre>
<p>All looks OK so far, we&rsquo;ll proceed to setting the columns data types</p>
<h2 id=column-data-format>Column data format<a hidden class=anchor aria-hidden=true href=#column-data-format>#</a></h2>
<p>Next, we&rsquo;ll set the proper type of certain columns</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;ChargedUserID&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;ChargedUserID&#34;</span>]<span style=color:#f92672>.</span>astype(<span style=color:#e6db74>&#34;category&#34;</span>)
df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>]<span style=color:#f92672>.</span>astype(<span style=color:#e6db74>&#34;category&#34;</span>)
df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>]<span style=color:#f92672>.</span>astype(<span style=color:#e6db74>&#34;category&#34;</span>)

df[<span style=color:#e6db74>&#34;Time&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_datetime(df[<span style=color:#e6db74>&#34;Date&#34;</span>], format <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;%H:%M:%S&#34;</span>)
df[<span style=color:#e6db74>&#34;DateTime&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_datetime(df[<span style=color:#e6db74>&#34;DateTime&#34;</span>], format <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;%Y-%m-</span><span style=color:#e6db74>%d</span><span style=color:#e6db74> %H:%M:%S&#34;</span>)

df[<span style=color:#e6db74>&#34;CallDuration&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_timedelta(df[<span style=color:#e6db74>&#34;CallDuration&#34;</span>])
df[<span style=color:#e6db74>&#34;CallDurationMV&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_timedelta(df[<span style=color:#e6db74>&#34;CallDurationMV&#34;</span>])
df[<span style=color:#e6db74>&#34;RingingDuration&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_timedelta(df[<span style=color:#e6db74>&#34;RingingDuration&#34;</span>])
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>info()
</code></pre></div><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 44890 entries, 0 to 63668
Data columns (total 9 columns):
 #   Column             Non-Null Count  Dtype          
---  ------             --------------  -----          
 0   ChargedUserID      44890 non-null  category       
 1   SubscriberName     44890 non-null  category       
 2   CommunicationType  44890 non-null  category       
 3   Date               44890 non-null  datetime64[ns] 
 4   Time               44890 non-null  datetime64[ns] 
 5   DateTime           44890 non-null  datetime64[ns] 
 6   CallDuration       44890 non-null  timedelta64[ns]
 7   CallDurationMV     44890 non-null  timedelta64[ns]
 8   RingingDuration    44890 non-null  timedelta64[ns]
dtypes: category(3), datetime64[ns](3), timedelta64[ns](3)
memory usage: 2.5 MB
</code></pre>
<h1 id=data-analysis>Data Analysis<a hidden class=anchor aria-hidden=true href=#data-analysis>#</a></h1>
<p>We&rsquo;ll start with some basic data exploration, to see some trends. Since we&rsquo;re only interested in incoming calls, we&rsquo;ll create a mask and filter the data</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> altair <span style=color:#66d9ef>as</span> alt
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>mask_incoming <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;IncomingTransfer&#34;</span>)
df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[mask_incoming]
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;Answered&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;SubscriberName&#34;</span>]<span style=color:#f92672>.</span>str<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;POSTE&#39;</span>), <span style=color:#e6db74>&#34;Answered&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
df<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>total_per_day <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#34;Date&#34;</span>)[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>]<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>reset_index()<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;CommunicationType&#34;</span>: <span style=color:#e6db74>&#34;Total&#34;</span>}, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
total_per_day<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>total_per_month <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(pd<span style=color:#f92672>.</span>Grouper(key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Date&#34;</span>, freq<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1M&#34;</span>))[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>]<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>reset_index()<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;CommunicationType&#34;</span>: <span style=color:#e6db74>&#34;Total&#34;</span>}, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
total_per_month<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>total_heatmap <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#34;Date&#34;</span>)[<span style=color:#e6db74>&#34;CommunicationType&#34;</span>]<span style=color:#f92672>.</span>count()<span style=color:#f92672>.</span>reset_index()<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;CommunicationType&#34;</span>: <span style=color:#e6db74>&#34;Total&#34;</span>}, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
heatmap_per_day <span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Chart(total_heatmap)<span style=color:#f92672>.</span>mark_rect()<span style=color:#f92672>.</span>encode(
    x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;date(Date):O&#39;</span>,
    y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;yearmonth(Date):O&#39;</span>,
    color<span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Color(<span style=color:#e6db74>&#39;Total:Q&#39;</span>, scale<span style=color:#f92672>=</span>alt<span style=color:#f92672>.</span>Scale(scheme<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;goldred&#39;</span>))
)<span style=color:#f92672>.</span>properties(
    width<span style=color:#f92672>=</span><span style=color:#ae81ff>600</span>
    )
heatmap_per_day
</code></pre></div><p><img loading=lazy src=/projects/call_analyzer_estimator/call_analyzer_estimator_1.png alt="Heatmap - calls per day of month">
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>heatmap_per_day_of_week <span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Chart(total_heatmap<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;CommunicationType&#34;</span>: <span style=color:#e6db74>&#34;Total&#34;</span>}, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>))<span style=color:#f92672>.</span>mark_rect()<span style=color:#f92672>.</span>encode(
    x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;day(Date):O&#39;</span>,
    y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;yearmonth(Date):O&#39;</span>,
    color<span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Color(<span style=color:#e6db74>&#39;Total:Q&#39;</span>, scale<span style=color:#f92672>=</span>alt<span style=color:#f92672>.</span>Scale(scheme<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;goldred&#39;</span>))
)<span style=color:#f92672>.</span>properties(
    width<span style=color:#f92672>=</span><span style=color:#ae81ff>600</span>
    )
heatmap_per_day_of_week
</code></pre></div><p><img loading=lazy src=/projects/call_analyzer_estimator/call_analyzer_estimator_2.png alt="Heatmap - calls per day of week">
</p>
<h1 id=estimator>Estimator<a hidden class=anchor aria-hidden=true href=#estimator>#</a></h1>
<p>Given a level of service, what is the minimum required ammount of agents to fulfill the service in question?</p>
<p>We&rsquo;ll check this by constructing time intervals from calls start and end time and we&rsquo;ll check at a certain frequency how many time intervals overlap. Since only one person can respond to a call, the total number of overlaps is the number of required agents.</p>
<p>Let&rsquo;s look at a simple example:</p>
<p><img loading=lazy src=/projects/call_analyzer_estimator/call_analyzer_estimator_call_diagram.png alt="Calls diagram">
</p>
<p>In the interval 8h00 - 8h30, we received 2 calls that were answered and we missed one call. In order to properly estimate the time occupation, we&rsquo;ll add 5min (the average conversation time) to missed calls. So, for this interval, we needed 3 agents to answer. In the next interval, 8h30 - 9h00, we still have 2 agents on call (Call1 and Call2), we assume that there is another fictive agent on missed Call3 and we receive another call that we missed. In total, for this interval, we would need 4 agents. In total, we can see that we need:</p>
<table>
<thead>
<tr>
<th>Interval</th>
<th>Agents needed</th>
</tr>
</thead>
<tbody>
<tr>
<td>8h00 - 8h30</td>
<td>3</td>
</tr>
<tr>
<td>8h30 - 9h00</td>
<td>4</td>
</tr>
<tr>
<td>9h00 - 9h30</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The time interval to check for call status will be smaller (5 min) in order to be more precise in our results.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df[<span style=color:#e6db74>&#34;call_start_dt&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;DateTime&#34;</span>]

df[<span style=color:#e6db74>&#34;call_end_dt&#34;</span>] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nan
df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;Answered&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;call_end_dt&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;DateTime&#34;</span>] <span style=color:#f92672>+</span> df[<span style=color:#e6db74>&#34;CallDuration&#34;</span>]

average_call_time <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;Answered&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;CallDuration&#34;</span>]<span style=color:#f92672>.</span>mean()
average_call_time <span style=color:#f92672>=</span> average_call_time<span style=color:#f92672>.</span>floor(<span style=color:#e6db74>&#34;s&#34;</span>)
average_call_time
</code></pre></div><pre><code>Timedelta('0 days 00:05:11')
</code></pre>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>df<span style=color:#f92672>.</span>loc[df[<span style=color:#e6db74>&#34;Answered&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;call_end_dt&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;DateTime&#34;</span>] <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>to_timedelta(average_call_time, unit <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;S&#34;</span>)
df<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_interval</span>(df):
    df[<span style=color:#e6db74>&#34;Time_interval&#34;</span>] <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Interval(df[<span style=color:#e6db74>&#34;call_start_dt&#34;</span>], df[<span style=color:#e6db74>&#34;call_end_dt&#34;</span>])
    <span style=color:#66d9ef>return</span> df

df[<span style=color:#e6db74>&#34;Time_interval&#34;</span>] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nan
df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>apply(create_interval, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
df<span style=color:#f92672>.</span>head()
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<p>Constructing time intervals between date A and date B, each day with opening hour X and closing hour Y is &mldr; tricky :(</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>unique_date_list <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;Date&#34;</span>]<span style=color:#f92672>.</span>unique()
date_range_start <span style=color:#f92672>=</span> []
date_range_end <span style=color:#f92672>=</span> []
frequency <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;5 minutes&#34;</span>)

<span style=color:#66d9ef>for</span> unique_date <span style=color:#f92672>in</span> unique_date_list:   
    day_range_start <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>date_range(start <span style=color:#f92672>=</span> unique_date <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;7 hours 30 minutes&#34;</span>),
                             end <span style=color:#f92672>=</span> unique_date <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;18 hours 30 minutes&#34;</span>) <span style=color:#f92672>-</span> frequency,
                             freq <span style=color:#f92672>=</span> frequency
                           )
    day_range_end <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>date_range(start <span style=color:#f92672>=</span> unique_date <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;7 hours 30 minutes&#34;</span>) <span style=color:#f92672>+</span> frequency,
                             end <span style=color:#f92672>=</span> unique_date <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;18 hours 30 minutes&#34;</span>),
                             freq <span style=color:#f92672>=</span> frequency
                           )
    
    date_range_start <span style=color:#f92672>+=</span> day_range_start
    date_range_end <span style=color:#f92672>+=</span> day_range_end
    
verification_range <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>IntervalIndex<span style=color:#f92672>.</span>from_arrays(date_range_start, date_range_end)
verification_range
</code></pre></div><pre><code>IntervalIndex([(2019-12-20 07:30:00, 2019-12-20 07:35:00], (2019-12-20 07:35:00, 2019-12-20 07:40:00], (2019-12-20 07:40:00, 2019-12-20 07:45:00], (2019-12-20 07:45:00, 2019-12-20 07:50:00], (2019-12-20 07:50:00, 2019-12-20 07:55:00] ... (2020-10-01 18:05:00, 2020-10-01 18:10:00], (2020-10-01 18:10:00, 2020-10-01 18:15:00], (2020-10-01 18:15:00, 2020-10-01 18:20:00], (2020-10-01 18:20:00, 2020-10-01 18:25:00], (2020-10-01 18:25:00, 2020-10-01 18:30:00]],
              closed='right',
              dtype='interval[datetime64[ns]]')
</code></pre>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>result <span style=color:#f92672>=</span> []
<span style=color:#66d9ef>for</span> verification_interval <span style=color:#f92672>in</span> verification_range:
    counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    
    <span style=color:#75715e># we&#39;re filtering the main dataframe as there is no point in searching for overlaps in the next day</span>
    mask_filter_left <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#34;call_start_dt&#34;</span>] <span style=color:#f92672>&gt;</span> verification_interval<span style=color:#f92672>.</span>left <span style=color:#f92672>-</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;24h&#34;</span>))
    mask_filter_right <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#34;call_end_dt&#34;</span>] <span style=color:#f92672>&lt;</span> verification_interval<span style=color:#f92672>.</span>right <span style=color:#f92672>+</span> pd<span style=color:#f92672>.</span>Timedelta(<span style=color:#e6db74>&#34;24h&#34;</span>))
    
    call_intervals <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[(mask_filter_left <span style=color:#f92672>&amp;</span> mask_filter_right), <span style=color:#e6db74>&#34;Time_interval&#34;</span>]
    
    <span style=color:#66d9ef>for</span> call_interval <span style=color:#f92672>in</span> call_intervals:
        <span style=color:#66d9ef>if</span> verification_interval<span style=color:#f92672>.</span>overlaps(call_interval):
            counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>      
    result<span style=color:#f92672>.</span>append({<span style=color:#e6db74>&#34;time_interval&#34;</span>: verification_interval,
                  <span style=color:#e6db74>&#34;total_overlaps&#34;</span>: counter})
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>estimator <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(result)
estimator<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<p>We got our results, but we&rsquo;ll only keep the starting date of the interval, it&rsquo;s much easier to construct graphs with simple dates than time intervals.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>estimator[<span style=color:#e6db74>&#34;DateTime&#34;</span>] <span style=color:#f92672>=</span> estimator[<span style=color:#e6db74>&#34;time_interval&#34;</span>]<span style=color:#f92672>.</span>apply(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>left)
estimator <span style=color:#f92672>=</span> estimator<span style=color:#f92672>.</span>loc[:,(<span style=color:#e6db74>&#34;total_overlaps&#34;</span>,<span style=color:#e6db74>&#34;DateTime&#34;</span>)]<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;total_overlaps&#34;</span>: <span style=color:#e6db74>&#34;Total&#34;</span>}, axis <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>estimator<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<h1 id=average--min--max-nb-of-agents-required-per-hour-per-day>Average / Min / Max nb of agents required per hour per day<a hidden class=anchor aria-hidden=true href=#average--min--max-nb-of-agents-required-per-hour-per-day>#</a></h1>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>estimator[<span style=color:#e6db74>&#34;Hour&#34;</span>] <span style=color:#f92672>=</span> estimator[<span style=color:#e6db74>&#34;DateTime&#34;</span>]<span style=color:#f92672>.</span>dt<span style=color:#f92672>.</span>hour
estimator[<span style=color:#e6db74>&#34;Day_nb&#34;</span>] <span style=color:#f92672>=</span> estimator[<span style=color:#e6db74>&#34;DateTime&#34;</span>]<span style=color:#f92672>.</span>dt<span style=color:#f92672>.</span>day
estimator<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_agg</span>(df):
    df[<span style=color:#e6db74>&#34;Total_mean&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;Total&#34;</span>]<span style=color:#f92672>.</span>mean()
    df[<span style=color:#e6db74>&#34;Total_mean&#34;</span>] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ceil(df[<span style=color:#e6db74>&#34;Total_mean&#34;</span>])
    df[<span style=color:#e6db74>&#34;Total_min&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;Total&#34;</span>]<span style=color:#f92672>.</span>min()
    df[<span style=color:#e6db74>&#34;Total_max&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;Total&#34;</span>]<span style=color:#f92672>.</span>max()
    
    <span style=color:#66d9ef>return</span> df

heatmap_table <span style=color:#f92672>=</span> estimator<span style=color:#f92672>.</span>groupby([<span style=color:#e6db74>&#34;Day_nb&#34;</span>, <span style=color:#e6db74>&#34;Hour&#34;</span>])<span style=color:#f92672>.</span>apply(calc_agg)<span style=color:#f92672>.</span>reset_index(drop <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
heatmap_table<span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5</span>)
</code></pre></div>
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>alt<span style=color:#f92672>.</span>data_transformers<span style=color:#f92672>.</span>disable_max_rows()

base <span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Chart(heatmap_table<span style=color:#f92672>.</span>rename({<span style=color:#e6db74>&#34;Day_nb&#34;</span>: <span style=color:#e6db74>&#34;Date&#34;</span>, <span style=color:#e6db74>&#34;Total_mean&#34;</span>: <span style=color:#e6db74>&#34;Mean&#34;</span>, <span style=color:#e6db74>&#34;Total_max&#34;</span>: <span style=color:#e6db74>&#34;Max&#34;</span>}))<span style=color:#f92672>.</span>encode(
    x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Hour:O&#39;</span>,
    y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Day_nb:O&#39;</span>
    )

color_avg <span style=color:#f92672>=</span> base<span style=color:#f92672>.</span>mark_rect()<span style=color:#f92672>.</span>encode(
    color<span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Color(<span style=color:#e6db74>&#39;Total_mean:Q&#39;</span>, scale<span style=color:#f92672>=</span>alt<span style=color:#f92672>.</span>Scale(scheme<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;goldred&#39;</span>))
    )

text_avg <span style=color:#f92672>=</span> base<span style=color:#f92672>.</span>mark_text(baseline<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;middle&#39;</span>)<span style=color:#f92672>.</span>encode(
    text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;max(Total_mean):Q&#39;</span>
    )

heatmap <span style=color:#f92672>=</span> color_avg <span style=color:#f92672>+</span> text_avg
heatmap
</code></pre></div><p><img loading=lazy src=/projects/call_analyzer_estimator/call_analyzer_estimator_3.png alt="Heatmap - average agents per day">
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>color_max <span style=color:#f92672>=</span> base<span style=color:#f92672>.</span>mark_rect()<span style=color:#f92672>.</span>encode(
    color<span style=color:#f92672>=</span> alt<span style=color:#f92672>.</span>Color(<span style=color:#e6db74>&#39;Total_max:Q&#39;</span>, scale<span style=color:#f92672>=</span>alt<span style=color:#f92672>.</span>Scale(scheme<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;goldred&#39;</span>))
    )

text_max <span style=color:#f92672>=</span> base<span style=color:#f92672>.</span>mark_text(baseline<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;middle&#39;</span>)<span style=color:#f92672>.</span>encode(
    text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;max(Total_max):Q&#39;</span>
    )

heatmap <span style=color:#f92672>=</span> color_max <span style=color:#f92672>+</span> text_max
<span style=color:#75715e>#heatmap</span>
</code></pre></div><p><img loading=lazy src=/projects/call_analyzer_estimator/call_analyzer_estimator_4.png alt="Heatmap - max agents per day">
</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://sorinbiriescu.github.io/en/tags/python/>Python</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/data-wrangling/>Data wrangling</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/data-analysis/>Data analysis</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/data-visualisation/>Data visualisation</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/pandas/>Pandas</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/altair/>Altair</a></li>
<li><a href=https://sorinbiriescu.github.io/en/tags/time-series/>Time series</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://sorinbiriescu.github.io/en/projects/apollo/>
<span class=title>¬´ Prev Page</span>
<br>
<span>Apollo</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://sorinbiriescu.github.io/en/>Sorin BIRIESCU</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>